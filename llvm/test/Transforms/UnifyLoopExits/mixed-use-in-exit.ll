; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -unify-loop-exits -S | FileCheck %s

; Loop consists of A, B and C:
; - A is the header
; - A and C are exiting blocks
; - B is an "internal" block that dominates exiting block C
; - D and return are exit blocks.

; Pattern: %return contains a phi node that receives values from
;          %entry, %A and %D. This mixes all the special cases in a single phi.

define i32 @foo(i32* %arg1, i32* %arg2) local_unnamed_addr align 2 {
; CHECK-LABEL: @foo(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP42:%.*]] = load i32, i32* [[ARG1:%.*]], align 4
; CHECK-NEXT:    [[CMP2:%.*]] = icmp slt i32 [[TMP42]], 0
; CHECK-NEXT:    br i1 [[CMP2]], label %A, label %return
; CHECK:       A:
; CHECK-NEXT:    [[TMP43:%.*]] = add i32 [[TMP42]], 1
; CHECK-NEXT:    [[CMP1:%.*]] = icmp slt i32 [[TMP42]], 0
; CHECK-NEXT:    br i1 [[CMP1]], label %B, label [[LOOPEXITBLOCK:%.*]]
; CHECK:       B:
; CHECK-NEXT:    [[TMP41:%.*]] = load i32, i32* [[ARG2:%.*]], align 4
; CHECK-NEXT:    br label %C
; CHECK:       C:
; CHECK-NEXT:    [[CMP:%.*]] = icmp slt i32 [[TMP42]], 0
; CHECK-NEXT:    br i1 [[CMP]], label %A, label [[LOOPEXITBLOCK]]
; CHECK:       D:
; CHECK-NEXT:    br label %return
; CHECK:       return:
; CHECK-NEXT:    [[PHI:%.*]] = phi i32 [ [[TMP41_MOVED:%.*]], %D ], [ [[TMP42]], [[ENTRY:%.*]] ], [ [[PHI_MOVED:%.*]], [[LOOPEXITBLOCK]] ]
; CHECK-NEXT:    ret i32 [[PHI]]
; CHECK:       LoopExitBlock:
; CHECK-NEXT:    [[TMP41_MOVED]] = phi i32 [ undef, %A ], [ [[TMP41]], %C ]
; CHECK-NEXT:    [[PHI_MOVED]] = phi i32 [ [[TMP43]], %A ], [ undef, %C ]
; CHECK-NEXT:    [[LOOPEXITGUARD_RETURN:%.*]] = phi i1 [ true, %A ], [ false, %C ]
; CHECK-NEXT:    br i1 [[LOOPEXITGUARD_RETURN]], label %return, label %D
;
entry:
  %tmp42 = load i32, i32* %arg1, align 4
  %cmp2 = icmp slt i32 %tmp42, 0
  br i1 %cmp2, label %A, label %return

A:                                       ; preds = %B, %A.lr.ph
  %tmp43 = add i32 %tmp42, 1
  %cmp1 = icmp slt i32 %tmp42, 0
  br i1 %cmp1, label %B, label %return

B:                                           ; preds = %A
  %tmp41 = load i32, i32* %arg2, align 4
  br label %C

C:
  %cmp = icmp slt i32 %tmp42, 0
  br i1 %cmp, label %A, label %D

D:
  br label %return

return:                                           ; preds = %B38, %A
  %phi = phi i32 [ %tmp41, %D ], [ %tmp43, %A ], [%tmp42, %entry]
  ret i32 %phi
}
